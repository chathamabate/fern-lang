
Introductory Notes:

    fern-lang will be a systems level language for the 8086.
    It will be designed such that all aspects of an operating
    system can be written in fern-lang. Thus, it will
    support assembly sections and higher level sections.

    Assembly sections will be denoted with "asm".
    Higher level sections will be denoted with "abstract".

Data Types:

    Primitives:
        u8  - unsigned 8-bit integer. (or ascii character)
        u16 - unsigned 16-bit integer.
        s8  - signed 8-bit integer.
        s16 - signed 16-bit integer.

    Pointers:
        *T - a 32-bit value (offset and segment) pointing to a value of type T.

    Procedures:
        local(T1, T2, T3, ...)  - A 16-bit offset into the current code segment
                                  pointing to a procedure accepting T1... as paramenters.
        global(T1, T2, T3, ...) - A 32-bit segment and offset of a procedure accepting
                                  T1... as parameters.
        
        NOTE: Procedure types are never standalone. They must be pointed to!
    
    Structures and Arrays: 
        [c]T- An array of type T with constant length c.

        { T1 L1; T2 L2; ... } - A structure is a composite type.
        
        NOTE: The labels are used to access the fields of the structure.
        They are not necessary for type equivelance. Two structures with
        the same field types are equivelant, regardless of the fields labels.

    Constants:
        const T - A value of type T which is unchanging.

Sections Types:

    A fern lang program will be broken into independent sections.
    The order of the given sections will be preserved during compilation.

    header section - header information about the binary being compiled.
    
    header {

    }

    raw section - This section contains assembly code with no setup.
    This section has no native support of parameters or local variables.
    This is all up to the user to define how they see fit.

    raw <name> {
        // Assembly...
    }

    procedure section - A procedure provides support for local variables,
    parameters, abstract code, and augmented assembly!

    (local|global) <name>
    (params...)
    [local variables....]
    text {
    asm:
       Assembly code... 
    
    abstract:
       Abstract code...
    } 

    data section - Where constants and global variables can be stored!

    data {
        type name; ...
    } 

Assembly Notes:

    Below are all recognized operands which are syntactically
    unique. 

    General Purpose Register:
        Byte Length:
            AL, CL, DL, BL, AH, CH, DH, BH
        Word Length:
            AX, CX, DX, BX, SP, BP, SI, DI

    Segment Register:
        ES, CS, SS, DS

    Immediate
        Note that the width of an immediate is inferred
        from its parent instruction. An immediate
        will either be interpreted as a 8-bit or 16-bit value.
    
    Memory:
        Byte Offset  
        Word Offset  
        Only Base or Index:
            BX, BP, SI, DI
        Base/Index + Byte Displacement
            (BX/BP/SI/DI) + D8
        Base/Index + Word Displacement
            (BX/BP/SI/DI) + D16
        Base + Index
            (BX/BP) + (SI/DI)
        Base + Index + Byte Displacement
            (BX/BP) + (SI/DI) + D8
        Base + Index + Word Displacement
            (BX/BP) + (SI/DI) + D16

    memptr32:
        32-bit immediate representing segment and 
        offset. Note, that an Immediate can be used
        as a 16-bit code segment offset.
   
    Label:
        Note that for now, all labels will resolve to
        16-bit current code segment offsets.

        Local Label
            (Ex .loop .end .continue)
        Global Label 
            (Ex puts printf start_kernel)

Syntax:

macros???

<Label> ::= ...

<Instr> ::= ...
    
